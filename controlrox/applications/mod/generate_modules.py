"""Module configuration generator for introspective modules.

This script reads JSON configuration files and generates Python class files
for introspective PLC modules.
"""
import json
from pathlib import Path
from typing import Any
from datetime import datetime


class ModuleGenerator:
    """Generates Python module classes from JSON configuration files."""

    def __init__(self, config_dir: str, output_dir: str):
        """Initialize the generator.

        Args:
            config_dir: Directory containing JSON config files
            output_dir: Directory where generated Python files will be written
        """
        self.config_dir = Path(config_dir)
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_all(self) -> list[str]:
        """Generate Python files for all JSON configs in config_dir.

        Returns:
            List of generated file paths
        """
        generated_files = []
        for config_file in self.config_dir.glob('*.json'):
            if config_file.name == 'module_config_schema.json':
                continue  # Skip schema file

            try:
                output_file = self.generate_from_config(config_file)
                generated_files.append(output_file)
                print(f"✓ Generated: {output_file}")
            except Exception as e:
                print(f"✗ Error generating {config_file.name}: {e}")

        return generated_files

    def generate_from_config(self, config_path: Path) -> str:
        """Generate a Python module class from a JSON config file.

        Args:
            config_path: Path to the JSON config file

        Returns:
            Path to the generated Python file
        """
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)

        # Generate Python code
        code = self._generate_class_code(config)

        # Write to output file
        output_file = self.output_dir / f"{config['class_name'].lower()}.py"
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(code)

        return str(output_file)

    def _generate_class_code(self, config: dict[str, Any]) -> str:
        """Generate Python class code from configuration.

        Args:
            config: Module configuration dictionary

        Returns:
            Generated Python code as a string
        """
        lines = []

        # Header comment
        lines.append('"""Auto-generated module class from JSON configuration.')
        lines.append('')
        if 'metadata' in config and 'description' in config['metadata']:
            lines.append(f"{config['metadata']['description']}")
        lines.append('')
        lines.append('DO NOT EDIT THIS FILE DIRECTLY.')
        lines.append('Edit the corresponding JSON config file and regenerate.')
        lines.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append('"""')

        # Imports
        lines.append('from controlrox.interfaces import ModuleControlsType')
        lines.append('from controlrox.applications.mod.meta import GeneratedModule')

        lines.append('')
        lines.append('')

        # Class definition
        class_name = config['class_name']
        lines.append(f"class {class_name}(GeneratedModule):")

        # Docstring
        if 'metadata' in config and 'description' in config['metadata']:
            lines.append(f'    """{config["metadata"]["description"]}"""')
        else:
            lines.append(f'    """Generated module class for {config["catalog_number"]}."""')

        # catalog_number property
        lines.append('')
        lines.append('    def get_catalog_number(self) -> str:')
        lines.append('        """The catalog number of the module."""')
        lines.append(f'        return \'{config["catalog_number"]}\'')

        # controls_type property
        lines.append('')
        lines.append('    def get_module_controls_type(self) -> ModuleControlsType:')
        lines.append('        """The controls type of the module."""')
        lines.append(f'        return ModuleControlsType.{config["controls_type"]}')

        # Connection points method
        if 'connection_points' in config:
            if 'input' in config['connection_points']:
                lines.append('')
                lines.append('    def get_input_connection_point(self) -> int:')
                lines.append('        """Get the input connection point for the module."""')
                lines.append(f'        return {config["connection_points"]["input"]}')

            if 'output' in config['connection_points']:
                lines.append('')
                lines.append('    def get_output_connection_point(self) -> int:')
                lines.append('        """Get the output connection point for the module."""')
                lines.append(f'        return {config["connection_points"]["output"]}')

            if 'config' in config['connection_points']:
                lines.append('')
                lines.append('    def get_config_connection_point(self) -> int:')
                lines.append('        """Get the configuration connection point for the module."""')
                lines.append(f'        return {config["connection_points"]["config"]}')

        # Connection sizes method
        if 'connection_sizes' in config:
            if 'input' in config['connection_sizes']:
                lines.append('')
                lines.append('    def get_input_connection_size(self) -> int:')
                lines.append('        """Get the input connection size for the module."""')
                lines.append(f'        return {config["connection_sizes"]["input"]}')

            if 'output' in config['connection_sizes']:
                lines.append('')
                lines.append('    def get_output_connection_size(self) -> int:')
                lines.append('        """Get the output connection size for the module."""')
                lines.append(f'        return {config["connection_sizes"]["output"]}')

            if 'config' in config['connection_sizes']:
                lines.append('')
                lines.append('    def get_config_connection_size(self) -> int:')
                lines.append('        """Get the configuration connection size for the module."""')
                lines.append(f'        return {config["connection_sizes"]["config"]}')

        # Generate required_imports method if specified
        if 'required_imports' in config:
            lines.append('')
            lines.append('    def get_required_imports(self) -> list[tuple[str, list[str]]]:')
            lines.append('        """Get the required datatype imports for the module."""')
            lines.append('        return [')
            for imp in config['required_imports']:
                path = imp['path'].replace('\\', '\\\\')
                elements = imp['elements']
                lines.append(f"            (r'{path}', {elements}),")
            lines.append('        ]')

        # Generate tag name methods
        if 'tag_name_methods' in config:
            methods = config['tag_name_methods']
            if 'safety_input' in methods:
                lines.append('')
                lines.append('    def get_safety_input_tag_name(self) -> str:')
                lines.append('        """Get the safety input tag name."""')
                template = methods['safety_input']
                code = self._generate_template_code(template)
                lines.append(f'        return {code}')

            if 'safety_output' in methods:
                lines.append('')
                lines.append('    def get_safety_output_tag_name(self) -> str:')
                lines.append('        """Get the safety output tag name."""')
                template = methods['safety_output']
                code = self._generate_template_code(template)
                lines.append(f'        return {code}')

            if 'standard_input' in methods:
                lines.append('')
                lines.append('    def get_standard_input_tag_name(self) -> str:')
                lines.append('        """Get the standard input tag name."""')
                template = methods['standard_input']
                code = self._generate_template_code(template)
                lines.append(f'        return {code}')

            if 'standard_output' in methods:
                lines.append('')
                lines.append('    def get_standard_output_tag_name(self) -> str:')
                lines.append('        """Get the standard output tag name."""')
                template = methods['standard_output']
                code = self._generate_template_code(template)
                lines.append(f'        return {code}')

        # Generate required_tags method
        if 'tags' in config:
            lines.append('')
            lines.append('    def get_required_tags(self, **__) -> list[dict]:')
            lines.append('        """Get the required tags for the module."""')

            # Check if controller is needed
            needs_controller = any(
                '{controller.' in tag.get('name_template', '')
                for tag in config['tags']
            )

            if needs_controller:
                lines.append('        if not self.controller:')
                lines.append('            raise ValueError("Controller not set for this module")')
                lines.append('')

            lines.append('        tags = []')
            for tag in config['tags']:
                lines.append('        tags.append({')

                # Handle tag name
                if 'name_method' in tag:
                    lines.append(f"            'tag_name': self.{tag['name_method']}(),")
                elif 'name_template' in tag:
                    template = tag['name_template']
                    code = self._generate_template_code(template)
                    lines.append(f"            'tag_name': {code},")

                # Add other tag properties
                if 'datatype' in tag:
                    lines.append(f"            'datatype': '{tag['datatype']}',")
                if 'tag_class' in tag:
                    lines.append(f"            'tag_class': '{tag['tag_class']}',")
                if 'description' in tag:
                    lines.append(f"            'description': '{tag['description']}',")

                lines.append('        })')

            lines.append('        return tags')

        # Generate safety rungs method
        if 'rungs' in config and 'safety' in config['rungs']:
            lines.append('')
            lines.append('    def get_required_safety_rungs(self, **__):')
            lines.append('        """Get the required safety rungs for the module."""')
            lines.append('        rungs = []')

            for rung in config['rungs']['safety']:
                lines.append('        rungs.append(self.controller.create_rung(')
                text_template = rung['text_template']
                text_code = self._generate_template_code(text_template)
                lines.append(f'            rung_text={text_code},')
                lines.append(f"            comment='{rung['comment']}'")
                lines.append('        ))')

            lines.append('        return rungs')

        # Generate standard rungs method
        if 'rungs' in config and 'standard' in config['rungs']:
            lines.append('')
            lines.append('    def get_required_standard_rungs(self, **__):')
            lines.append('        """Get the required standard rungs for the module."""')
            lines.append('        rungs = []')

            for rung in config['rungs']['standard']:
                lines.append('        rungs.append(self.controller.create_rung(')
                text_template = rung['text_template']
                text_code = self._generate_template_code(text_template)
                lines.append(f'            rung_text={text_code},')
                lines.append(f"            comment='{rung['comment']}'")
                lines.append('        ))')

            lines.append('        return rungs')

        # Standard to Safety mapping method
        if 'standard_to_safety_mapping' in config:
            lines.append('')
            lines.append('    def get_required_standard_to_safety_mapping(self, **__) -> tuple[str, str]:')
            lines.append('        """Get mapping from standard tags to safety tags."""')
            lines.append('        mapping = []')
            standard_method = config['standard_to_safety_mapping']['standard_name_method']
            safety_method = config['standard_to_safety_mapping']['safety_name_method']
            lines.append(f'        mapping = ('
                         f'self.{standard_method}(), '
                         f'self.{safety_method}()'
                         f')')
            lines.append('        return mapping')

        lines.append('')
        return '\n'.join(lines)

    def _generate_template_code(self, template: str) -> str:
        """Generate Python code for a template string with placeholders.

        Args:
            template: Template string with {placeholders}

        Returns:
            Python f-string code
        """
        # Replace {module.name} with {self.base_module.name}
        template = template.replace('{module.name}', '{self.base_module.name}')
        template = template.replace('{module.parent_module}', '{self.base_module.parent_module}')
        template = template.replace('{controller.process_name}', '{self.controller.process_name}')

        return f"f'{template}'"

    def generate_init_file(self, generated_files: list[str]) -> None:
        """Generate __init__.py to export all generated modules.

        Args:
            generated_files: List of generated Python file paths
        """
        lines = []
        lines.append('"""Auto-generated module exports."""')
        lines.append('# This file is auto-generated. Do not edit directly.')
        lines.append('')

        class_names = []
        for file_path in generated_files:
            module_name = Path(file_path).stem
            # Read the class name from the file
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                # Find class definition
                for line in content.split('\n'):
                    if line.startswith('class '):
                        class_name = line.split('(')[0].replace('class ', '').strip()
                        lines.append(f'from .{module_name} import {class_name}')
                        class_names.append(class_name)
                        break

        lines.append('')
        lines.append('__all__ = [')
        for class_name in class_names:
            lines.append(f"    '{class_name}',")
        lines.append(']')
        lines.append('')

        init_file = self.output_dir / '__init__.py'
        with open(init_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))

        print(f"✓ Generated: {init_file}")


def main():
    """Main entry point for the generator."""
    # Determine paths
    script_dir = Path(__file__).parent
    config_dir = script_dir / 'config'
    output_dir = script_dir / 'generated'

    print(f"Config directory: {config_dir}")
    print(f"Output directory: {output_dir}")
    print('')

    # Create generator
    generator = ModuleGenerator(str(config_dir), str(output_dir))

    # Generate all modules
    print("Generating modules...")
    generated_files = generator.generate_all()

    # Generate __init__.py
    if generated_files:
        print('')
        print("Generating __init__.py...")
        generator.generate_init_file(generated_files)

    print('')
    print(f"✓ Successfully generated {len(generated_files)} module(s)")


if __name__ == '__main__':
    main()
